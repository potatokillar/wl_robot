# IMU 驱动模块 (ImuDrv) 详细设计文档

本文档详细描述了惯性测量单元（IMU）驱动模块的实现逻辑、硬件接口、数据处理流程及异常处理机制。

## 1. 硬件接口层

### 1.1 通信接口规范
IMU 模块通过 UART（通用异步收发传输器）接口与主控板进行通信。

*   **物理接口**: UART (TTL电平)
*   **波特率**: 115200 bps
*   **数据位**: 8 bit
*   **停止位**: 1 bit
*   **校验位**: None (无校验)
*   **流控**: None (无流控)

### 1.2 寄存器配置与数据时序
IMU 工作在主动上传模式（Active Mode），无需主控端发送查询指令。上电后，IMU 会按照固定的频率自动发送数据包。

*   **数据包格式**: `Header (0x55) | Type (1 Byte) | Data (8 Bytes) | Checksum (1 Byte)`
*   **总包长**: 11 字节
*   **字节序**: Little-Endian (小端模式)

### 1.3 硬件初始化流程
初始化过程由 `ImuNode::Init()` 函数执行，主要步骤如下：

1.  **设备查找**: 遍历配置文件中定义的 IMU 设备节点列表（如 `/dev/ttyUSB0`, `/dev/ttyS0` 等）。
2.  **串口配置**:
    *   打开串口设备文件。
    *   设置波特率 115200，8N1 模式。
    *   设置阻塞读取模式或超时读取模式。
3.  **状态复位**: 重置内部状态标志位 `isOk_`，记录启动时间戳 `imuInfo.startTime`。
4.  **线程启动**: 创建并启动独立的数据接收线程 `ImuNode::Loop()`。

```cpp
// 伪代码示例：初始化流程
void ImuNode::Init() {
    for (auto dev : config.imu_devices) {
        if (uart.Open(dev)) {
            uart.SetParam(115200, 8, 'N', 1);
            isOk_ = true;
            thread = std::thread(&ImuNode::Loop, this);
            break;
        }
    }
}
```

## 2. 数据处理流程

### 2.1 原始数据采集
*   **采样机制**: 驱动在一个独立的线程 `Loop()` 中运行，通过 `uart_->Read(1)` 阻塞或带超时地读取字节流。
*   **缓冲区管理**: 读取到的原始字节流被推入标准库队列 `std::queue<uint8_t> uartData_` 中进行缓存，等待解析。

### 2.2 数据校验机制
数据包的有效性通过以下两步验证：
1.  **包头检测**: 检查数据流中是否存在 `0x55` 作为帧头。
2.  **校验和 (Checksum)**: 计算前 10 个字节的累加和（Sum），并与第 11 个字节（Checksum Byte）进行比对。
    *   公式: `Sum = Byte[0] + Byte[1] + ... + Byte[9]`
    *   验证: `if (Sum == Byte[10]) Pass else Fail`

### 2.3 传感器数据解析算法
驱动支持三种类型的 IMU 数据包解析：

| 类型码 (Type) | 数据内容 | 解析公式 (Raw -> Physical) | 单位 |
| :--- | :--- | :--- | :--- |
| **0x51** | 加速度 (Acc) | `val = raw / 32768.0 * 16.0 * 9.8` | m/s² |
| **0x52** | 角速度 (Gyro) | `val = raw / 32768.0 * 2000.0 * (π/180)` | rad/s |
| **0x53** | 欧拉角 (Angle) | `val = raw / 32768.0 * π` | rad |
| **0x59** | 四元数 (Quat) | `val = raw / 32768.0` | N/A (归一化值) |

*   **加速度**: 量程 ±16g，转换为 m/s²。
*   **角速度**: 量程 ±2000°/s，转换为 弧度/秒 (rad/s)。
*   **欧拉角**: 范围 ±180°，转换为 弧度 (rad)。
*   **四元数**: 归一化四元数，用于姿态解算。

## 3. 核心功能模块

### 3.1 姿态解算
IMU 硬件内部已完成传感器融合，直接输出四元数（0x59 数据包）和欧拉角（0x53 数据包）。
*   **四元数优先**: 驱动优先使用 0x59 数据包中的四元数作为姿态真值，因为四元数不存在万向节死锁问题。
*   **完整性检查**: 只有当接收到包含四元数的 0x59 包时，才认为一帧完整的姿态数据构建完成，并标记 `dataValid = true`。

### 3.2 数据分发
解析完成后，驱动通过消息总线（Message Bus）发布话题 `qr::imuData`，供上层控制算法订阅。
```cpp
MsgTrySend("qr::imuData", imuData);
```

### 3.3 软件架构与状态机
驱动采用简单的 **初始化 -> 运行 -> 错误恢复** 状态流转：

1.  **初始化 (Init)**: 配置硬件，启动线程。
2.  **运行 (Loop)**:
    *   读取串口数据。
    *   解析协议帧。
    *   发布数据。
    *   调用 `ErrorDetect()` 监控健康状态。
3.  **错误检测 (ErrorDetect)**:
    *   检查 `lastReadOk` 时间戳。
    *   如果超时（如 > 1000ms 未收到有效数据），触发错误处理。

## 4. 错误处理机制

### 4.1 传感器通信失败处理
*   **超时监测**: `ErrorDetect()` 函数周期性检查最后一次成功读取数据的时间 (`lastReadOk`)。
*   **判定阈值**: `ALIVE_TIME = 1000 ms`。如果当前时间与 `lastReadOk` 之差超过此阈值，判定为通信丢失。
*   **恢复策略**:
    1.  打印错误日志 (`LOG_ERROR`)。
    2.  发送传感器错误事件 `qr::imu_error` (True)。
    3.  播放语音提示或报警 (`sensorError`)。
    4.  **自动重连**: 如果检测到串口句柄失效，启动独立线程重新执行 `Init()` 尝试恢复连接。

### 4.2 数据异常检测
*   **校验和错误**: 如果校验和不匹配，直接丢弃当前包头，滑动窗口寻找下一个 `0x55`。
*   **包序检查**: 通过 `packetCount` 统计各类型包的接收数量，用于调试丢包率。

### 4.3 错误码定义
*   **qr::imu_error**: 布尔值消息。
    *   `true`: IMU 故障或通信中断。
    *   `false`: IMU 工作正常。

## 5. 关键参数配置
*   **串口波特率**: 115200 (这是 IMU 硬件的默认出厂设置，不可更改除非刷写固件)。
*   **重力加速度常量**: 9.8 m/s²。
*   **角速度单位转换**: `deg2rad = π / 180`。

## 6. 代码引用
*   **头文件**: `app/driver/imuDrv.hpp`
*   **实现文件**: `app/driver/imuDrv.cpp`
